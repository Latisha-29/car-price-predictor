const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');
const { spawn } = require('child_process');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// In-memory storage for cars data
let carsData = [];
let statsData = {};

// Load car data from CSV on startup
function loadCarData() {
    const csvPath = path.join(__dirname, 'data', 'car_data.csv');
    
    if (!fs.existsSync(csvPath)) {
        console.log('CSV file not found, using sample data');
        carsData = getSampleCarData();
        calculateStats();
        return;
    }

    carsData = [];
    fs.createReadStream(csvPath)
        .pipe(csv())
        .on('data', (row) => {
            // Parse and clean the data
            const car = {
                id: carsData.length + 1,
                carId: parseInt(row.car_ID) || 0,
                symboling: parseInt(row.symboling) || 0,
                carName: row.CarName || '',
                fueltype: row.fueltype || '',
                aspiration: row.aspiration || '',
                doornumber: row.doornumber || '',
                carbody: row.carbody || '',
                drivewheel: row.drivewheel || '',
                enginelocation: row.enginelocation || '',
                wheelbase: parseFloat(row.wheelbase) || 0,
                carlength: parseFloat(row.carlength) || 0,
                carwidth: parseFloat(row.carwidth) || 0,
                carheight: parseFloat(row.carheight) || 0,
                curbweight: parseInt(row.curbweight) || 0,
                enginetype: row.enginetype || '',
                cylindernumber: row.cylindernumber || '',
                enginesize: parseInt(row.enginesize) || 0,
                fuelsystem: row.fuelsystem || '',
                boreratio: parseFloat(row.boreratio) || 0,
                stroke: parseFloat(row.stroke) || 0,
                compressionratio: parseFloat(row.compressionratio) || 0,
                horsepower: parseInt(row.horsepower) || 0,
                peakrpm: parseInt(row.peakrpm) || 0,
                citympg: parseInt(row.citympg) || 0,
                highwaympg: parseInt(row.highwaympg) || 0,
                price: parseFloat(row.price) || 0
            };
            carsData.push(car);
        })
        .on('end', () => {
            console.log(`Loaded ${carsData.length} cars from CSV`);
            calculateStats();
        })
        .on('error', (error) => {
            console.error('Error reading CSV:', error);
            carsData = getSampleCarData();
            calculateStats();
        });
}

// Calculate statistics from car data
function calculateStats() {
    if (!carsData.length) return;

    const totalCars = carsData.length;
    const avgPrice = Math.round(carsData.reduce((sum, car) => sum + car.price, 0) / totalCars);

    // Price distribution
    const priceRanges = [
        { min: 0, max: 5000, range: '$0-5k' },
        { min: 5000, max: 10000, range: '$5-10k' },
        { min: 10000, max: 15000, range: '$10-15k' },
        { min: 15000, max: 20000, range: '$15-20k' },
        { min: 20000, max: 25000, range: '$20-25k' },
        { min: 25000, max: 30000, range: '$25-30k' },
        { min: 30000, max: Infinity, range: '$30k+' }
    ];

    const priceDistribution = priceRanges.map(range => ({
        range: range.range,
        count: carsData.filter(car => car.price >= range.min && car.price < range.max).length
    }));

    // Fuel type distribution
    const fuelTypes = carsData.reduce((acc, car) => {
        acc[car.fueltype] = (acc[car.fueltype] || 0) + 1;
        return acc;
    }, {});

    const fuelTypeDistribution = Object.entries(fuelTypes).map(([type, count]) => ({
        type,
        count
    }));

    // Body type distribution
    const bodyTypes = carsData.reduce((acc, car) => {
        acc[car.carbody] = (acc[car.carbody] || 0) + 1;
        return acc;
    }, {});

    const bodyTypeDistribution = Object.entries(bodyTypes).map(([type, count]) => ({
        type,
        count
    }));

    statsData = {
        totalCars,
        avgPrice,
        priceDistribution,
        fuelTypeDistribution,
        bodyTypeDistribution
    };
}

// API Routes
app.get('/api/cars', (req, res) => {
    try {
        res.json(carsData);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch cars data' });
    }
});

app.get('/api/stats', (req, res) => {
    try {
        res.json(statsData);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch statistics' });
    }
});

app.post('/api/predict', async (req, res) => {
    try {
        const { fueltype, carbody, enginesize, horsepower, curbweight, cylindernumber, highwaympg } = req.body;

        // Validate input
        if (!fueltype || !carbody || !enginesize || !horsepower || !curbweight || !cylindernumber || !highwaympg) {
            return res.status(400).json({ error: 'Missing required fields' });
        }

        const inputData = {
            fueltype,
            carbody,
            enginesize: parseInt(enginesize),
            horsepower: parseInt(horsepower),
            curbweight: parseInt(curbweight),
            cylindernumber,
            highwaympg: parseInt(highwaympg)
        };

        // Try to use Python ML service
        try {
            const prediction = await callPythonMLService(inputData);
            res.json(prediction);
        } catch (pythonError) {
            console.log('Python ML service failed, using fallback prediction');
            // Fallback to JavaScript prediction
            const fallbackPrediction = calculateFallbackPrediction(inputData);
            res.json(fallbackPrediction);
        }

    } catch (error) {
        console.error('Prediction error:', error);
        res.status(500).json({ error: 'Prediction failed' });
    }
});

// Call Python ML service
function callPythonMLService(data) {
    return new Promise((resolve, reject) => {
        const pythonProcess = spawn('python3', [
            path.join(__dirname, 'ml_service.py'),
            JSON.stringify(data)
        ]);

        let result = '';
        let error = '';

        pythonProcess.stdout.on('data', (data) => {
            result += data.toString();
        });

        pythonProcess.stderr.on('data', (data) => {
            error += data.toString();
        });

        pythonProcess.on('close', (code) => {
            if (code !== 0) {
                reject(new Error(`Python script failed: ${error}`));
                return;
            }

            try {
                const prediction = JSON.parse(result);
                resolve({
                    predictedPrice: prediction.predicted_price,
                    confidence: prediction.confidence
                });
            } catch (parseError) {
                reject(new Error('Failed to parse prediction result'));
            }
        });

        // Timeout after 10 seconds
        setTimeout(() => {
            pythonProcess.kill();
            reject(new Error('Python prediction timeout'));
        }, 10000);
    });
}

// Fallback prediction calculation
function calculateFallbackPrediction(data) {
    const basePrice = 5000;
    const engineFactor = data.enginesize * 50;
    const horsepowerFactor = data.horsepower * 80;
    const weightFactor = data.curbweight * 2;

    let predictedPrice = basePrice + engineFactor + horsepowerFactor + (weightFactor * 0.5);

    // Adjust for fuel type
    if (data.fueltype === 'diesel') {
        predictedPrice *= 1.1;
    }

    // Adjust for body type
    const bodyMultipliers = {
        'convertible': 1.3,
        'sedan': 1.0,
        'hatchback': 0.9,
        'wagon': 1.1,
        'hardtop': 1.2
    };

    predictedPrice *= (bodyMultipliers[data.carbody] || 1.0);

    // Add some randomness for realism
    const randomFactor = 0.9 + (Math.random() * 0.2); // Â±10%
    predictedPrice *= randomFactor;

    return {
        predictedPrice: Math.round(predictedPrice),
        confidence: 0.85
    };
}

// Sample car data for fallback
function getSampleCarData() {
    return [
        {
            id: 1,
            carId: 1,
            symboling: 3,
            carName: "alfa-romero giulia",
            fueltype: "gas",
            aspiration: "std",
            doornumber: "two",
            carbody: "convertible",
            drivewheel: "rwd",
            enginelocation: "front",
            wheelbase: 88.6,
            carlength: 168.8,
            carwidth: 64.1,
            carheight: 48.8,
            curbweight: 2548,
            enginetype: "dohc",
            cylindernumber: "four",
            enginesize: 130,
            fuelsystem: "mpfi",
            boreratio: 3.47,
            stroke: 2.68,
            compressionratio: 9.0,
            horsepower: 111,
            peakrpm: 5000,
            citympg: 21,
            highwaympg: 27,
            price: 13495.0
        }
    ];
}

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        carsLoaded: carsData.length 
    });
});

// Start server
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    loadCarData();
});

module.exports = app;